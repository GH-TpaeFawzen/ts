#!/usr/bin/env expect --

# http://stackoverflow.com/questions/5302120/general-string-quoting-for-tcl
proc escape {str} {
  subst -nocommands -novariables $str
}

# http://stackoverflow.com/questions/4346750/regular-expression-literal-text-span
proc re_escape {str} {
  regsub -all {\W} [escape $str] {\\&}
}

proc prompt {prompt str} {
  expect -re ^[re_escape $prompt] { 
    type $str
    observe $str
  }
}

proc type {str} {
  send [escape $str]
}

proc observe {str} {
  expect {
    -re ^[regsub "\n" [re_escape $str] "\r\n"] { }
    timeout  { exit 1 }
  }
}

proc skip_to {str} {
  expect {
    -re ^.*[regsub "\n" [re_escape $str] "\r\n"] { }
    timeout  { exit 1 }
  }
}

proc script {shell ps1 ps2 script} {
  global spawn_id

  # set stty_init raw
  stty rows 25
  stty columns 80
  spawn -noecho /usr/bin/env "PS1=$ps1" "PS2=$ps2" $shell

  set i 0
  set max [llength $script]
  while { $i < $max } {
    set arg [lindex $script $i]
  
    switch -- $arg {
      $       {
                incr i;
                # throw away escape text prior to prompt
                # ex "\u001b[?1034h" (first prompt)
                # ex "\r\u001b[K\r" (reprompt)
                expect -notransfer -re "^(.*)[re_escape $ps1]" {
                  expect -ex $expect_out(1,string)
                }
                
                prompt $ps1 [lindex $script $i] 
              }
      >       { incr i; prompt $ps2 [lindex $script $i] }
      ...     { incr i; skip_to [lindex $script $i] }
      -       { incr i; type [lindex $script $i] }
      =       { incr i; observe [lindex $script $i] }
      default { observe $arg }
    }
  
    incr i
  }

  # wait
  send_user "\n"
}

exp_internal 1

# assert_script "\
# $ for n in one two; do
# >  echo $n
# > done
# o:...:e
# two
# "
script /bin/sh {$ } {> } {
  $ {for n in one two; do\u000A}
  > {  echo $n\u000A}
  > {done\u000A}
  {o} ... {e\u000A}
  {two\u000A}
}

# assert_script '\
# $ printf "%s\n" one two
# one
# two
# '
script /bin/sh {$ } {> } {
  $ {printf "%s\\n" one two\u000A}
  {one\u000A}
  {two\u000A}
}

# $ gi{{<tab>}}<bel>t
script /bin/sh {$ } {> } {
  $ {gi} - {	} {\u0007t}
}

# Makes me think that one-off simple stuff should be tested this
# way -- and what is the place for that?  If it's complex then
# perhaps it warrents it's own expect script.
#
# Maybe in that case provide some functions to call such that 
# the output from the expect script can be used by ts?

# set timeout 1

# at prompt - scan to typing OR end of line and prompt
# at line - scan to typing OR end of line and expect
# at typing - type, resume scanning (so if you want \n, add it yourself)

# assert_script "\
# $ c{{<tab><tab>}}\u0007
# Display all :...: possibilities? (y or n){{y}}
# :...:
# --More--{{q}}
# $ c
# "
script /bin/sh {$ } {> } {
  $ {c} - {		} {\u0007\u000A}
  {Display all} ... {possibilities? (y or n)} - {y}
  ... 
  {--More--} - {q}
  $ {c}
}

# assert_script "\
# $ gi{{<tab>}}\u0007t{<return>}
# :...:
# "

script /bin/sh {$ } {> } {
  $ {gi} - {	} {\u0007t} - {\u000A} {\u000A}
  ... 
}

# hidden conflicts with keys
# assert_script "\
# $ printf -
# -$ printf ...
# :...:$ printf '$'
# $$ printf '>'
# >$ echo done
# done
# "
script /bin/sh {$ } {> } {
  $ {printf -\u000A}
  = {-} $ {printf ...\u000A}
  = {...} $ {printf '$'\u000A}
  = {$} $ {printf '>'\u000A}
  = {>} $ {echo done\u000A}
  {done\u000A}
}

# Process
# * scan for PS1 ($ ), PS2 (> ), SPAN (:. .:), INPUT ({{ }})