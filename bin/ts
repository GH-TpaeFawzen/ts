#!/bin/bash
############################################################################
ts_progname="${0##*/}"
ts_author="Simon Chiang"
ts_version="1.0.0-beta"
ts_release_date="2012-09-07"
ts_url="http://github.com/thinkerbot/ts"

ts_usage="usage: %s [-achmrsv] [-t TS_TMP_DIR]"
if [ ts = "$ts_progname" ]
then ts_usage="$ts_usage [TEST_FILES...]\n"
else ts_usage="$ts_usage [TEST_NAMES...]\n"
fi
ts_opt="       %s   %s\n"

ts_args=""
while [ $OPTIND -le $# ]
do
  if getopts "acdhmrst:v" ts_option
  then
    case $ts_option in
      a  )  TS_FILTER=false ;;
      c  )  TS_COLOR=true ;;
      d  )  TS_DEBUG=true; TS_MODE=verbose ;;
      h  )  printf "$ts_usage" "$ts_progname"
            printf "$ts_opt" "-a" "show all tests"
            printf "$ts_opt" "-c" "color output"
            printf "$ts_opt" "-h" "prints this help"
            printf "$ts_opt" "-m" "monitor output"
            printf "$ts_opt" "-r" "remove tmp dir (rm -r)"
            printf "$ts_opt" "-s" "stream output"
            printf "$ts_opt" "-t" "set the test tmp dir (default tmp)"
            printf "$ts_opt" "-v" "verbose output (show stderr)"
            printf "\nversion %s -- %s\n" "$ts_version" "$ts_url"
            exit 0 ;;
      m  )  TS_REPORT=monitor ;;
      r  )  TS_REMOVE_TMP_DIR=true ;;
      s  )  TS_REPORT=stream ;;
      t  )  TS_TMP_DIR=$OPTARG ;;
      v  )  TS_MODE=verbose ;;
      \? )  printf "$ts_usage" "$ts_progname"
            exit 2 ;;
    esac
  else
    ts_args="$ts_args \${$OPTIND}" 
    OPTIND=$(($OPTIND + 1))
  fi
done
eval set -- "$ts_args"

TS_USR_DIR="${TS_USR_DIR:-$(pwd)}"
TS_TMP_DIR="${TS_TMP_DIR:-$TS_USR_DIR/tmp}"

TS_COLOR=${TS_COLOR:-false}
TS_DEBUG=${TS_DEBUG:-false}
TS_FILTER=${TS_FILTER:-true}
TS_REPORT=${TS_REPORT:-monitor}
TS_MODE=${TS_MODE:-normal}
TS_REMOVE_TMP_DIR=${TS_REMOVE_TMP_DIR:-false}

TS_PASS="${TS_PASS:-[32m}"
TS_FAIL="${TS_FAIL:-[1;31m}"
TS_NORM="${TS_NORM:-[0m}"
TS_NOEX="${TS_NOEX:-[1;33m}"

mkdir -p "$TS_TMP_DIR"
ts_status_file="$TS_TMP_DIR/status"
ts_monitor_file="$TS_TMP_DIR/monitor"

############################################################################
# private functions

ts_pattern () {
  printf "%s" "$1"
  shift 1

  if [ 0 -ne $# ]
  then printf "|%s" "$@"
  fi
}

ts_sources () {
  sed -ne '
s/^[[:space:]]*\.[[:space:]]/source /
/^[[:space:]]*source[[:space:]]/!d

s/^[[:space:]]*source[[:space:]]//
/^ts[[:space:]]*$/d
s/#.*//
p
' "$1"
}

ts_list () {
  if [ 0 -ne $# ]
  then
    grep -onE "^[[:space:]]*(${test_pattern:-test_\w+})[[:space:]]+\(\)" /dev/null "$@" |
    sed -e 's/^\([^:]*\):\([^:]*\):\([^ ]*\) .*/\3 \1:\2/'

    if [ true = "$TS_TESTS_IN_SOURCE" ]
    then
      for file in "$@"
      do
        eval ts_list $(ts_sources "$file") |
        awk -v file="$file" '{ $2=file " -> " $2; print }'
      done
    fi
  fi
}

ts_structure () {
  rm "$ts_status_file" 2>/dev/null
  awk -v status_file="$ts_status_file" '
function readbytes (bytes) {
  # account for trailing 'x'
  bytes -= 1

  # read bytes
  while(getline == 1 && (bytes -= length + 1) > 0) {
    print "  " $0
  }

  # manually remove trailing x if needed
  if(bytes < 0) {
    $0 = substr($0, 1, length + bytes + 1)
  }

  if(length > 0) {
    print "  " $0
    $0=""
  }
}

BEGIN { npass=nfail=0 }
/^\[/ { descr=$0 }
/^P/  { printf("P %s\n", descr); readbytes($2); npass++; printf("\n") }
/^F/  { printf("F %s\n", descr); readbytes($2); nfail++; printf("\n") }
/^X/  { printf("X %s\n", descr); readbytes($2); nfail++; printf("\n") }
END   { printf("%d %d\n", npass, nfail) >> status_file }
'
}

ts_monitor () {
  rm "$ts_monitor_file" 2> /dev/null
  sed -lne "
w $ts_monitor_file
/^P/a\\
.
/^F/a\\
F
/^X/a\\
-
" | tr -ud "\n" >&2
  printf "\n\n" >&2

  cat "$ts_monitor_file"
}

ts_filter () {
  if [ true = "$TS_FILTER" ]
  then sed -lne "
H
/^$/ {
x
s/^\n\([FX]\)/\1/p
}
"
  else cat
  fi
}

ts_color () {
  if [ true = "$TS_COLOR" ]
  then sed -lne "
s/^P \[\([^]]*\)/[$TS_PASS\1$TS_NORM/
s/^F \[\([^]]*\)/[$TS_FAIL\1$TS_NORM/
s/^X \[\([^]]*\)/[$TS_NOEX\1$TS_NORM/
p
"
  else cat
  fi
}

ts_color_or_format () {
  if [ true = "$TS_COLOR" ]
  then ts_color
  else sed -le '
/^[PFX]/ {
  h
  s/^[PFX] //
}
/^$/ {
  g
  s/^\([PFX]\).*$/\1\
/
}
'
  fi
}

ts_check_status () {
  awk -v nsec="$1" '
BEGIN { npass=nfail=0 }
      { npass += $1; nfail += $2; }
END   { printf("%d pass %d fail %d s\n", npass, nfail, nsec); if(nfail > 0) exit 1 }
' < "$ts_status_file"

  ts_exitstatus=$?

  if [ "true" = "$TS_REMOVE_TMP_DIR" ]
  then rm -r "$TS_TMP_DIR"
  fi

  return $ts_exitstatus
}

ts_report () {
  case "$TS_REPORT" in
    (monitor)
      ts_start_time=$SECONDS
      ts_structure | ts_monitor | ts_filter | ts_color_or_format
      ts_end_time=$SECONDS
      ts_check_status "$(($ts_end_time - $ts_start_time))" >&2
      ;;
    (stream)
      ts_structure | ts_filter | ts_color
      ts_check_status > /dev/null
      ;;
    (raw)
      cat
      ;;
  esac
}

# Runs a specific test.  In that case the test output is not filtered or
# changed. the exit status is the exit status of the specific test.
ts_run_test () {
  if [ -e "$test_dir" ] && ! rm -r "$test_dir"
  then
    printf "could not remove existing test dir: %s\n" "$test_dir"
    exit 1
  fi

  # input /dev/null so that tests which read from stdin will not hang
  exec </dev/null

  if [ true = "$TS_DEBUG" ]
  then set -x
  fi

  trap 'teardown' EXIT
  setup && "$test_name"
  ts_exitstatus=$?
  trap - EXIT
  teardown && return $ts_exitstatus
}

ts_run_test_suite () {
  test_file="$0"
  test_case="${test_file##*/}"
  test_case="${test_case%\.*}"
  test_pattern="$(ts_pattern "$@")"

  ts_list "$test_file" |
  while read test_name desc
  do
    test_dir="$TS_TMP_DIR/$test_case/$test_name"
    printf "[%s] %s\n" "$desc" "$test_name"

    # run the test by calling back into the test file
    # * use stdout for progress, stderr for debug information
    # * a zero exit status is considered a pass, otherwise fail
    # * capture as a variable to calculate length
    # * use a subprocess to prevent leakage (ex set -x)
    # * append x to preserve trailing newline
    if ts_stdout=$(
      if [ verbose = "$TS_MODE" ]
      then (ts_run_test 2>&1)
      else (ts_run_test 2>/dev/null)
      fi
      ts_exitstatus=$?
      printf x
      exit $ts_exitstatus
      )
    then ts_status=P
    else ts_status=F
    fi

    printf "%s %d\n%s\n" "$ts_status" "${#ts_stdout}" "$ts_stdout"
  done | ts_report
}

ts_run_test_files () {
  export TS_USR_DIR
  export TS_TMP_DIR

  export TS_COLOR
  export TS_FILTER
  export TS_MODE
  export TS_DEBUG

  for test_file in "$@"
  do
    if [ -x "$test_file" ]
    then TS_REPORT="raw" "$test_file"
    else printf "[%s] not executable\nX 1\nx\n" "$test_file"
    fi
  done | ts_report
}

############################################################################
# public functions

if ! type setup > /dev/null 2>&1
then
setup () {
  true
}
fi

if ! type teardown > /dev/null 2>&1
then
teardown () {
  true
}
fi

# Flunks unless the numbers $1 (expected) and $2 (actual) are the same.
assert_status () {
  expected=$1; actual=$2

  if ! [ $actual -eq $expected ]
  then 
    printf "expected status %s but was %s\n" "$expected" "$actual"
    exit 1
  fi
}

# Flunks unless the variables $1 (expected) and $2 (actual) are the same. 
# Reads from stdin for '-'.  '-' is assumed if $2 is not specified.
assert_output () {
  expected="$1"; actual="${2:--}"

  if [ x- = x"$expected" ]
  then
    expected=$(cat; printf x)
    expected=${expected%x}
  fi

  if [ x- = x"$actual" ]
  then
    actual=$(cat; printf x)
    actual=${actual%x}
  fi

  if [ x"$actual" != x"$expected" ]
  then
    mkdir -p "$(dirname "$test_dir")"
    printf "%s" "$expected" > "$test_dir.e.txt"
    printf "%s" "$actual"   > "$test_dir.a.txt"
    printf "unequal output:\n"
    diff "$test_dir.e.txt" "$test_dir.a.txt"
    exit 1
  fi
}

############################################################################

# Run the test files if this script is executed directly.
if [ ts = "$ts_progname" ]
then ts_run_test_files "$@"
else ts_run_test_suite "$@"
fi
