#!/bin/sh
############################################################################
export TS_USR_DIR
export TS_TMP_DIR
export TS_CLEANUP

use="usage: %s [-c] [-h] [-t TMPDIR] [TEST_FILES...]\n"
opt="       %s   %s\n"
while getopts "cht:x" option
do
  case $option in
  c  )  TS_CLEANUP=true ;;
  h  )  printf "$use" "$0"
        printf "$opt" "-c" "cleanup tmp dir on complete"
        printf "$opt" "-h" "prints this help"
        printf "$opt" "-t" "test tmp dir"
        exit 0 ;;
  t  )  TS_TMP_DIR=$OPTARG ;;
  \? )  printf "$use" "$0"
        exit 2 ;;
  esac
done
shift $(($OPTIND - 1))

TS_USR_DIR="$(pwd)"
TS_TMP_DIR="${TS_TMP_DIR:-$TS_USR_DIR/tmp}"
TS_CLEANUP="${TS_CLEANUP:-false}"

############################################################################
# Count the number of $1 chars on stdin
count () {
grep -o "$1" | wc -l | tr -d " "
}

# Check the input stream for output in the format:
#
#   [test/case:10] test_name
#   + true
#   P
#
# Partition failing output to $1, discard passing output.  Print to stdout '.'
# for passing tests and 'F' otherwise.
monitor () {
sed -ne "
/^\[/ b show
H
$ !b
:show
x

/P\$/a\\
.
/F\$/a\\
F

s/F\$//w $1
" | tr -d "\n"
}

# Print '-' to stdout and a message to stderr.
skip () {
printf "-"
printf "[%s] %s\n\n" "$1" "$2" >&2
continue
}

# Abbreviate stdin by deleting xtrace lines using PS4="$PS4-"
untrace () {
sed -e "
/^${PS4:0:1}\{0,\}$PS4- /d
/^${PS4}PS4='${PS4}- '/d
"
}
############################################################################
printf "Started\n"

# Make and expand TS_TMP_DIR
mkdir -p "$TS_TMP_DIR"
TS_TMP_DIR="$(cd "$TS_TMP_DIR" || exit 1; pwd)"

# Prepare log files
log="$TS_TMP_DIR/tslog"
err="$TS_TMP_DIR/tserr"
rm -f "$log" "$err"
touch "$log" "$err"

# Run the test files
start=$SECONDS
for test_file in "$@"
do
  out="$TS_TMP_DIR/$(basename "$test_file").out"
  rm -f "$out"

  if ! [ -f "$test_file" ]
  then skip "$test_file" "not a file" 2>> "$err"
  fi

  if ! [ -x "$test_file" ]
  then skip "$test_file" "not executable" 2>> "$err"
  fi

  "$test_file" 2>&1 | monitor "$out" | tee -a "$log"
  cat "$out" | untrace >> "$err"
done
end=$SECONDS

# Report results
printf "\nFinished in %ss\n\n" "$(($end - $start))"
cat "$err" >&2
printf "%s pass, %s fail\n" "$(count '\.' < "$log")" "$(count 'F' < "$log")"

# Cleanup
if [ "true" = "$TS_CLEANUP" ]
then rm -r "$TS_TMP_DIR"
fi
