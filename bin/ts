#!/bin/sh
############################################################################
export TS_USR_DIR
export TS_TMP_DIR
export TS_CLEANUP
export TS_DEBUG
export TS_VERBOSE

use="usage: %s [-c] [-d] [-h] [-t TMPDIR] [-v] [TEST_FILES...]\n"
opt="       %s   %s\n"
while getopts "cdht:v" option
do
  case $option in
  c  )  TS_CLEANUP=true ;;
  d  )  TS_DEBUG=true ;;
  h  )  printf "$use" "$0"
        printf "$opt" "-c" "cleanup (rm -r) tmp dir on complete"
        printf "$opt" "-d" "debug mode - capture stderr for each test"
        printf "$opt" "-h" "prints this help"
        printf "$opt" "-t" "test tmp dir"
        exit 0 ;;
  t  )  TS_TMP_DIR=$OPTARG ;;
  v  )  TS_VERBOSE=true ;;
  \? )  printf "$use" "$0"
        exit 2 ;;
  esac
done
shift $(($OPTIND - 1))

if [ 0 -eq $# ]
then exit
fi

TS_USR_DIR="$(pwd)"
TS_TMP_DIR="${TS_TMP_DIR:-$TS_USR_DIR/tmp}"
TS_CLEANUP="${TS_CLEANUP:-false}"
TS_DEBUG="${TS_DEBUG:-false}"
TS_VERBOSE="${TS_VERBOSE:-false}"

############################################################################
# Check the input stream for output in the format:
#
#   [test/case:10] test_name
#   + true
#   P
#
# Partition failing output to $1, discard passing output.  Print to stdout '.'
# for passing tests and 'F' otherwise.
monitor () {
sed -lne "
/^\[/ b show
H
$ !b
:show
x

/\.\$/a\\
.
/F\$/a\\
F

s/F\$//w $1
" | tr -ud "\n"
}

format () {
  sed
}
############################################################################

# Make and expand TS_TMP_DIR
mkdir -p "$TS_TMP_DIR"
TS_TMP_DIR="$(cd "$TS_TMP_DIR" || exit 1; pwd)"

# Prepare log files
output="$TS_TMP_DIR/output"
errors="$TS_TMP_DIR/errors"
rm -f "$output" "$errors"
touch "$output" "$errors"

# Run the test files
grep -onEH "^ *test_\w+ +\(\)" "$@" |
tr -d " ()" |
tr ":" " "  | {

if ! [ "true" = "$TS_DEBUG" ]
then exec 2> /dev/null
fi

npass=0
nfail=0
start=$SECONDS
while read test_file lineno test_name
do
  # run the test by calling back into the test file
  # * use stdout for progress, stderr for debug information
  # * a zero exit status is considered a pass, otherwise fail
  if
    printf "[$test_file:$lineno:$test_name]\n"
    "$test_file" "$test_name"
  then
    printf ".\n"
    ((npass++))
  else
    printf "F\n"
    ((nfail++))
  fi
done
end=$SECONDS
printf "%s pass, %s fail, %s s\n" "$npass" "$nfail" "$(($end - $start))" > "$output"

} 2>&1 |
if [ "true" = "$TS_VERBOSE" ]
then format
else monitor "$errors"
fi

printf "\n"
cat "$errors" | format >&2
cat "$output"

# Cleanup
if [ "true" = "$TS_CLEANUP" ]
then rm -r "$TS_TMP_DIR"
fi
