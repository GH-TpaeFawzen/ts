#!/bin/bash
############################################################################
export TS_USR_DIR
export TS_TMP_DIR

use="usage: %s [-c] [-d] [-f] [-h] [-p] [-t TMPDIR] [-v] [TEST_FILES...]\n"
opt="       %s   %s\n"
while getopts "cdfhpt:v" option
do
  case $option in
  c  )  cleanup=true ;;
  d  )  debug=true ;;
  f  )  format=true ;;
  h  )  printf "$use" "$0"
        printf "$opt" "-c" "cleanup (rm -r) tmp dir on complete"
        printf "$opt" "-d" "debug mode - capture stderr for each test"
        printf "$opt" "-f" "format output with color and indentation"
        printf "$opt" "-h" "prints this help"
        printf "$opt" "-p" "preview the tests to be run"
        printf "$opt" "-t" "set the test tmp dir (default tmp)"
        printf "$opt" "-v" "verbose output"
        exit 0 ;;
  p  )  preview=true ;;
  t  )  TS_TMP_DIR=$OPTARG ;;
  v  )  verbose=true ;;
  \? )  printf "$use" "$0"
        exit 2 ;;
  esac
done
shift $(($OPTIND - 1))

TS_USR_DIR="$(pwd)"
TS_TMP_DIR="${TS_TMP_DIR:-$TS_USR_DIR/tmp}"
cleanup="${cleanup:-false}"
debug="${debug:-false}"
format="${format:-false}"
preview="${preview:-false}"
verbose="${verbose:-false}"

PASS=`echo -e '\033[32m'`
FAIL=`echo -e '\033[1;31m'`
NORM=`echo -e '\033[0m'`

############################################################################
list () {
if [ $# -gt 0 ]
then
  grep -onEH "^ *test_\w+ +\(\)" "$@" |
  tr -d " ()" |
  tr ":" " "
fi
}

run () {
if [ "true" = "$debug" ]
then exec 2>&1 
else exec 2> /dev/null
fi

npass=0
nfail=0
start=$SECONDS
while read test_file lineno test_name
do
  # run the test by calling back into the test file
  # * use stdout for progress, stderr for debug information
  # * a zero exit status is considered a pass, otherwise fail
  if
    printf "[$test_file:$lineno] $test_name\n"
    "$test_file" "$test_name" | sed -e "s/^/  /"
    [ 0 -eq $PIPESTATUS ]
  then
    printf "P\n"
    ((npass++))
  else
    printf "F\n"
    ((nfail++))
  fi
done
end=$SECONDS

printf "%s pass %s fail %s s\n" "$npass" "$nfail" "$(($end - $start))" > "$1"
}

# Check the input stream for output in the format:
#
#   [test/case:10] test_name
#   + true
#   P
#
# Partition failing output to $1, discard passing output.  Print to stdout '.'
# for passing tests and 'F' otherwise.
format () {
# Parse by head line
# /^\[/ !{
# H
# \$ !d
# }
# x

sed -lne "
/^\[/ !{
H
\$ !d
}
x

/P\$/ {
s/^\[\([^]]*\)/[$PASS\1$NORM/
a\\
.
}

/F\$/ {
s/^\[\([^]]*\)/[$FAIL\1$NORM/
a\\
F
}

s/[PF]\$//
/^\$/ !w $1
\$ a\\
nn
" | tr -ud "\n" | tr -u "n" "\n"
}

no_format () {
sed -l
}

filter () {
sed -lne "
/^\[/ !{
H
\$ !d
}
x

/^\$/ d
/P\$/ d
/^\[[^[]*\[32m/ d

p
"
}

no_filter () {
sed -l
}

############################################################################

mkdir -p "$TS_TMP_DIR"
stdout="$TS_TMP_DIR/stdout"
stderr="$TS_TMP_DIR/stderr"
rm -f "$stdout" "$stderr"
touch "$stdout" "$stderr"
exitstatus=0

if [ "true" = "$preview" ]
then
  list "$@"
else
  list "$@" | run "$stderr" |
  if [ "true" = "$format" ]
  then
    format "$stdout" >&2
    cat "$stdout"
  else
    no_format
  fi |
  if [ "true" = "$verbose" ]
  then no_filter
  else filter
  fi

  cat "$stderr" >&2

  [ "0" = "$(cut -d " " -f 3 "$stderr")" ]
  exitstatus=$?
fi

if [ "true" = "$cleanup" ] && [ -e "$TS_TMP_DIR" ]
then rm -r "$TS_TMP_DIR"
fi

exit $exitstatus
