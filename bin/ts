#!/bin/bash
############################################################################
ts_progname="${0##*/}"
ts_version="1.0"
ts_author="Simon Chiang"
ts_usage="usage: %s [-c] [-d] [-f] [-h] [-r] [-t TS_TMP_DIR] [-v] %s\n"
if [ "ts" = "$ts_progname" ]
then ts_args="[TEST_FILES...]"
else ts_args="[TEST_NAMES...]"
fi
ts_opt="       %s   %s\n"

while getopts "cdfhlmn:rt:v" ts_option
do
  case $ts_option in
    c  )  ts_cleanup=true ;;
    d  )  ts_debug=true ;;
    f  )  ts_format=true ;;
    h  )  printf "$ts_usage" "$ts_progname" "$ts_args"
          printf "$ts_opt" "-c" "cleanup tmp dir on complete"
          printf "$ts_opt" "-d" "debug mode"
          printf "$ts_opt" "-f" "format output"
          printf "$ts_opt" "-h" "prints this help"
          printf "$ts_opt" "-m" "monitor output"
          printf "$ts_opt" "-r" "raw output (overrides -fmv)"
          printf "$ts_opt" "-t" "set the test tmp dir (default tmp)"
          printf "$ts_opt" "-v" "verbose output (show passing tests)"
          printf "\n"
          exit 0 ;;
    l  )  ts_list=true ;;
    m  )  ts_monitor=true ;;
    n  )  TS_NAME=$OPTARG ;;
    r  )  ts_raw=true ;;
    t  )  TS_TMP_DIR=$OPTARG ;;
    v  )  ts_verbose=true ;;
    \? )  printf "$ts_usage" "$ts_progname" "$ts_args"
          exit 2 ;;
  esac
done
shift $(($OPTIND - 1))

TS_USR_DIR="${TS_USR_DIR:-$(pwd)}"
TS_TMP_DIR="${TS_TMP_DIR:-$TS_USR_DIR/tmp}"

mkdir -p "$TS_TMP_DIR"
ts_stat_file="$TS_TMP_DIR/stat"
ts_mon_file="$TS_TMP_DIR/mon"

TS_PASS="${TS_PASS:-[32m}"
TS_FAIL="${TS_FAIL:-[1;31m}"
TS_NORM="${TS_NORM:-[0m}"
TS_NOEX="${TS_NOEX:-[1;33m}"

############################################################################
# private functions

ts_list () {
  for test_pattern in "${@:-test_\w+}"
  do grep -onE "^ *$test_pattern +\(\)" "$0"
  done |
  tr ":" " "
}

ts_structure () {
  awk '
function readbytes (bytes) {
  # account for trailing 'x'
  bytes -= 1

  # read bytes
  while(getline == 1 && (bytes -= length + 1) > 0) {
    print "  " $0
  }

  # manually remove trailing x if needed
  if(bytes < 0) {
    $0 = substr($0, 1, length + bytes + 1)
  }

  if(length > 0) {
    print "  " $0
    $0=""
  }
}

BEGIN   { npass=nfail=0 }
/^\[/   { print }
/^P/    { readbytes($2); npass++; printf "P\n" }
/^F/    { readbytes($2); nfail++; printf "F\n" }
/^X/    { readbytes($2); nfail++; printf "X\n" }
END     { printf "%d %d", npass, nfail > "'"$ts_stat_file"'" }
'
}

ts_monitor () {
  if [ "true" = "$ts_monitor" ]
  then
    sed -lne "
w $ts_mon_file
/P\$/a\\
.
/F\$/a\\
F
/X\$/a\\
-
" | tr -ud "\n" >&2
    printf "\n" >&2
    cat "$ts_mon_file"
  else cat
  fi
}

ts_format () {
  if [ "true" = "$ts_format" ]
  then sed -lne "
/^\[/ {
x
1 p
d
}
H
/^[PFX]/ {
x
/P\$/ s/^\[\([^]]*\)/[$TS_PASS\1$TS_NORM/
/F\$/ s/^\[\([^]]*\)/[$TS_FAIL\1$TS_NORM/
/X\$/ s/^\[\([^]]*\)/[$TS_NOEX\1$TS_NORM/
s/[PFX]\$//
p
}
"
  else cat
  fi
}

ts_filter () {
  if [ "true" = "$ts_verbose" ]
  then cat
  else sed -lne "
/^\[/ {
x
d
}
H
/^[PFX]/ {
x
/[FX]\$/ p
}
"
  fi
}

ts_report () {
  ts_start_time=$SECONDS
  if [ "true" = "$ts_raw" ]
  then cat
  else
    ts_structure "$ts_stat_file" |
    ts_monitor "$ts_mon_file" |
    ts_filter |
    ts_format
  fi
  ts_end_time=$SECONDS

  if [ "true" != "$ts_raw" ]
  then
    cat "$ts_stat_file" | awk -v time="$(($ts_end_time - $ts_start_time))" '{
      npass=$1; nfail=$2
      printf "%d pass %d fail %d s\n", npass, nfail, time
      if(nfail > 0) exit 1;
    }' >&2
  fi
}

# Runs a specific test.  In that case the test output is not filtered or
# changed. the exit status is the exit status of the specific test.
ts_run_test () {
  if [ -e "$test_dir" ] && ! rm -r "$test_dir"
  then
    printf "could not remove existing test dir: %s\n" "$test_dir"
    exit 1
  fi

  # input /dev/null so that tests which read from stdin will not hang
  exec </dev/null

  setup && "$test_name"
  ts_exitstatus=$?
  teardown && return $ts_exitstatus
}

ts_run_test_suite () {
  test_file="$0"
  test_case="${test_file##*/}"
  test_case="${test_case%\.*}"

  ts_list "$@" |
  while read test_lineno test_name junk
  do
    test_dir="$TS_TMP_DIR/$test_case/$test_name"

    # run the test by calling back into the test file
    # * use stdout for progress, stderr for debug information
    # * a zero exit status is considered a pass, otherwise fail
    # * capture as a variable to calculate length
    # * use a subprocess to prevent leakage (ex set -x)
    # * append x to preserve trailing newline
    if ts_stdout=$(
      if [ "true" = "$ts_debug" ]
      then (ts_run_test 2>&1)
      else (ts_run_test 2>/dev/null)
      fi
      ts_exitstatus=$?
      printf x
      exit $ts_exitstatus
      )
    then ts_status=P
    else ts_status=F
    fi

    printf "[%s:%s] %s\n%s %d\n%s\n" "$test_file" "$test_lineno" "$test_name" "$ts_status" "${#ts_stdout}" "$ts_stdout"
  done  | ts_report
}

ts_run_test_files () {
  export TS_USR_DIR
  export TS_TMP_DIR
  export TS_NAME

  for test_file in "$@"
  do
    if [ -x "$test_file" ]
    then "$test_file" -r
    else printf "[%s] not executable\nX 1\nx\n" "$test_file"
    fi
  done | ts_report
}

############################################################################
# public functions

setup () {
  true
}

teardown () {
  true
}

# Runs a command and asserts it's exit status is 0.
assert () {
  "$@"
  exitstatus=$?

  if ! [ 0 -eq $exitstatus ]
  then
    printf "exit status %s:\n%s\n" "$exitstatus" "$*"
    exit 1
  fi
}

# Flunks unless the numbers $1 (expected) and $2 (actual) are the same.
assert_status () {
  expected=$1; actual=$2

  if ! [ $actual -eq $expected ]
  then 
    printf "expected status %s but was %s\n" "$expected" "$actual"
    exit 1
  fi
}

# Flunks unless the variables $1 (expected) and $2 (actual) are the same. 
# Reads from stdin for '-'.  '-' is assumed if $2 is not specified.
assert_output () {
  expected="$1"; actual="${2:--}"

  # use x to protect against '-' on ancient systems
  if [ x"$expected" = x"-" ]
  then
    expected=$(cat; printf x)
    expected=${expected%x}
  fi

  if [ x"$actual" = x"-" ]
  then
    actual=$(cat; printf x)
    actual=${actual%x}
  fi

  if [ x"$actual" != x"$expected" ]
  then
    mkdir -p "$(dirname "$test_dir")"
    printf "%s" "$expected" > "$test_dir.e.txt"
    printf "%s" "$actual"   > "$test_dir.a.txt"
    printf "unequal output:\n"
    diff "$test_dir.e.txt" "$test_dir.a.txt"
    exit 1
  fi
}

# Flunks unless the extended regular expression $1 (expected pattern) and $2
# (actual) match.  Reads from stdin for '-'.   '-' is assumed if $2 is not
# specified.
assert_match () {
  pattern="$1"; actual="${2:--}"

  # use x to protect against '-' on ancient systems
  if [ x"$pattern" = x"-" ]
  then
    pattern=$(cat; printf x)
    pattern=${pattern%x}
  fi

  if [ x"$actual" = x"-" ]
  then
    actual=$(cat; printf x)
    actual=${actual%x}
  fi

  if ! printf "%b" "$actual" | grep -qE "$pattern"
  then
    printf "output does not match pattern: %s\n%s\n" "$pattern" "$actual"
    exit 1
  fi
}
############################################################################

# Run the test files if this script is executed directly. Otherwise, set a
# trap to run the current test suite after the tests have been defined.
if [ "ts" = "$ts_progname" ]
then ts_run_test_files "$@"
else trap "ts_run_test_suite $*; exit \$?" EXIT
fi
