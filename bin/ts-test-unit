############################################################################
# This file is meant to be sourced into the actual test file.
############################################################################

TS_USR_DIR="$(pwd)"
TS_TMP_DIR="${TS_TMP_DIR:-$TS_USR_DIR/tmp}"
TS_CLEANUP="${TS_CLEANUP:-false}"
test_file="$0"
test_name="$1"
output=
status=

############################################################################

setup () {
  true
}

teardown () {
  true
}

# Flunks unless the numbers $1 (expected) and $2 (actual) are the same.
assert_status () {
  PS4="$PS4- "
  expected=$1; actual=$2

  if [ $actual -ne $expected ]
  then 
    printf "expected status $expected but was $actual\n"
    exit 1
  fi
  PS4="${PS4%- }"
}

# Flunks unless the strings $1 (expected) and $2 (actual) are the same.  Reads
# from stdin for '-'.
assert_output () {
  PS4="$PS4- "
  expected="$1"; actual="$2"

  if [ "$expected" = "-" ]
  then expected="$(cat)"
  fi

  if [ "$actual" = "-" ]
  then actual="$(cat)"
  fi

  if [ "$actual" != "$expected" ]
  then
    mkdir -p "$test_dir"
    printf "$expected" > "$test_dir.expect"
    printf "$actual"   > "$test_dir.actual"
    printf "unequal output:\n"
    diff "$test_dir.expect" "$test_dir.actual"
    exit 1
  fi
  PS4="${PS4%- }"
}

# # Normally stderr is directed at a trace file so that it can be used to debug
# # errors, and set -e is on so that any non-zero exit will terminate the
# # script.  Note stdout is still set to the terminal for inline debugging.
# #
# # capture sets stdout/stderr to the terminal and turns off set -e. The
# # terminal fd is saved to the fd (default 3) so that it can be restored by
# # capture_off. The idea is that within a capture the script behaves exactly as
# # normal.
# #
# # Note capture_off returns the same as the last command.
# capture_on () {
# 
# }
# 
# capture_off () {
# 
# }
# 
# # Runs the command and sets output,status to the stdout of the command and
# # status to the status of the command.  Does not exit if the command fails.
# capture () {
#   capture_on
#   output="$($@)"
#   status=$?
#   capture_off
# }

# Runs a specific test.  In that case the test output is not filtered or
# changed. the exit status is the exit status of the specific test.
run_test () {
  if [ "" = "$test_name" ]
  then
    run_test_suite
    exit $?
  fi

  # close stdin so that commands expecting stdin will not hang
  exec <&-

  # prepare the test dir
  test_case="$(basename "$test_file")"
  test_case="${test_case%\.*}"
  test_dir="$TS_TMP_DIR/$test_case/$test_name"

  if [ -e "$test_dir" ] && ! rm -r "$test_dir"
  then
    printf "could not remove existing test dir: %s\n" "$test_dir" >&2
    exit 1
  fi

  setup
  "$test_name"
  teardown
}

# Prints to stdout the lineno and name of tests in file $1, identified as
# functions named like 'test_'.
test_suite () {
  grep -onE "^ *test_\w+ +\(\)" "$1" |
  tr -d " ()" |
  tr ":" " "
}

# Runs all tests in the test suite.
run_test_suite () {
  test_suite "$test_file" |
  while read lineno test_name
  do
    # run the test by calling back into the test file
    # * use stdout for progress, stderr for debug information
    # * a zero exit status is considered a pass, otherwise fail
    printf "[$test_file:$lineno] $test_name\n"

    if "$test_file" "$test_name"
    then printf "P\n"
    else printf "exit: %s\nF\n" "$?"
    fi
  done
}
