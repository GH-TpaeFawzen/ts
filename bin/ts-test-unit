############################################################################
version="1.0"
author="Simon Chiang"

usage="usage: %s [-c] [-d] [-f] [-h] [-l] [-r] [-t TS_TMP_DIR] [-v] %s%s\n"
args="${args:-[TEST_NAMES...]}"
progname="${0##*/}"
opt="       %s   %s\n"

while getopts "cdfhlmrt:v" option
do
  case $option in
    c  )  cleanup=true ;;
    d  )  debug=true ;;
    f  )  format=true ;;
    h  )  printf "$usage" "$progname" "$args" "$doc"
          printf "$opt" "-c" "cleanup tmp dir on complete"
          printf "$opt" "-d" "debug mode"
          printf "$opt" "-f" "format output"
          printf "$opt" "-h" "prints this help"
          printf "$opt" "-l" "list the tests to be run"
          printf "$opt" "-m" "monitor output"
          printf "$opt" "-r" "raw output (overrides -fmv)"
          printf "$opt" "-t" "set the test tmp dir (default tmp)"
          printf "$opt" "-v" "verbose output (show passing tests)"
          printf "\n"
          exit 0 ;;
    l  )  list=true ;;
    m  )  monitor=true ;;
    r  )  raw=true ;;
    t  )  TS_TMP_DIR=$OPTARG ;;
    v  )  verbose=true ;;
    \? )  printf "$usage" "$0" "$args"
          exit 2 ;;
  esac
done
shift $(($OPTIND - 1))

TS_USR_DIR="${TS_USR_DIR:-$(pwd)}"
TS_TMP_DIR="${TS_TMP_DIR:-$TS_USR_DIR/tmp}"

TS_PASS="${TS_PASS:-[32m}"
TS_FAIL="${TS_FAIL:-[1;31m}"
TS_NORM="${TS_NORM:-[0m}"
TS_NOEX="${TS_NOEX:-[1;37m}"

############################################################################
setup () {
  true
}

teardown () {
  true
}

# Runs a command and asserts it's exit status is 0.
assert () {
  "$@"
  exitstatus=$?

  if ! [ 0 -eq $exitstatus ]
  then
    printf "exit status %s:\n%s\n" "$exitstatus" "$@"
    exit 1
  fi
}

# Flunks unless the numbers $1 (expected) and $2 (actual) are the same.
assert_status () {
  expected=$1; actual=$2

  if ! [ $actual -eq $expected ]
  then 
    printf "expected status %s but was %s\n" "$expected" "$actual"
    exit 1
  fi
}

# Flunks unless the variables $1 (expected) and $2 (actual) are the same. 
# Reads from stdin for '-'.
assert_output () {
  expected="$1"; actual="$2"

  # use x to protect against '-' on ancient systems
  if [ x"$expected" = x"-" ]
  then expected="$(cat)"
  fi

  if [ x"$actual" = x"-" ]
  then actual="$(cat)"
  fi

  if [ x"$actual" != x"$expected" ]
  then
    mkdir -p "$(dirname "$test_dir")"
    printf "%s" "$expected" > "$test_dir.e.txt"
    printf "%s" "$actual"   > "$test_dir.a.txt"
    printf "unequal output:\n"
    diff "$test_dir.e.txt" "$test_dir.a.txt"
    exit 1
  fi
}

# Flunks unless the extended regular expression $1 (expected pattern) and $2
# (actual) match.  Reads from stdin for '-'.
assert_match () {
  patttern="$1"; actual="$2"

  # use x to protect against '-' on ancient systems
  if [ x"$patttern" = x"-" ]
  then patttern="$(cat)"
  fi

  if [ x"$actual" = x"-" ]
  then actual="$(cat)"
  fi

  if ! [[ "$actual" =~ $patttern ]]
  then
    printf "output does not match pattern: %s\n%s\n" "$patttern" "$actual"
    exit 1
  fi
}

############################################################################

ts_list () {
  grep -onE "^ *test_\w+ +\(\)" "$@" |
  tr -d " ()" |
  tr ":" " "
}

ts_structure () {
  sed -lne '
/^%/ {
1 !G
/^% P/a\
P
/^% F/a\
F
/^% X/a\
X
s/^% [PFX] //
s/\n//
p
c\

x
d
}
s/^/  /
H
'
}

ts_monitor () {
mon_file="$1"

if [ "true" = "$monitor" ]
then sed -lne "
/^\[/ !{
H
$ !d
}
x
1 d

w $mon_file
/P\$/a\\
.
/F\$/a\\
F
/X\$/a\\
-
\$ a\\
n
" | 
  tr -ud "\n" | 
    tr -u "n" "\n" >&2
cat "$mon_file"
else cat
fi
}

ts_format () {
if [ "true" = "$format" ]
then sed -lne "
/^\[/ !{
H
$ !d
}
x
1 p

/P\$/ s/^\[\([^]]*\)/[$TS_PASS\1$TS_NORM/
/F\$/ s/^\[\([^]]*\)/[$TS_FAIL\1$TS_NORM/
/X\$/ s/^\[\([^]]*\)/[$TS_NOEX\1$TS_NORM/
s/[PFX]\$//p
"
else cat
fi
}

ts_filter () {
if [ "true" = "$verbose" ]
then cat
else sed -lne "
/^\[/ !{
H
$ !d
}
x
1 d
/P\$/ d
/^\[[^[]*\[32m/ d
s/^[^[]*//p
"
fi
}

ts_process () {
raw_file="$1"; mon_file="$2";

if [ "true" = "$raw" ]
then cat
else   
tee "$raw_file" |
  ts_structure |
    ts_monitor "$mon_file" |
      ts_format |
        ts_filter
fi
}

# Runs a specific test.  In that case the test output is not filtered or
# changed. the exit status is the exit status of the specific test.
ts_run_test () {
if [ -e "$test_dir" ] && ! rm -r "$test_dir"
then
  printf "could not remove existing test dir: %s\n" "$test_dir"
  exit 1
fi

exec <&-

setup
"$test_name"
teardown
}

ts_report () {
raw_file="$1"

if [ "true" != "$raw" ]
then
  npass="$(grep -c '^% P' "$raw_file")"
  npass=${npass:-0}

  nfail="$(grep -c '^% F' "$raw_file")"
  nfail=${nfail:-0}

  nnoex="$(grep -c '^% X' "$raw_file")"
  nnoex=${nnoex:-0}

  printf "%s pass %s fail %s s\n" "$npass" "$(($nfail + $nnoex))" "$(($end_time - $start_time))" >&2

  if [ "true" = "$cleanup" ]
  then rm -r "$TS_TMP_DIR"
  fi

  [ "0" = "$(($nfail + $nnoex))" ]
fi
}

run_ts () {
test_file="$0"
test_case="${test_file##*/}"
test_case="${test_case%\.*}"

if [ "true" = "$list" ]
then
  ts_list "$test_file"
  exit
fi

mkdir -p "$TS_TMP_DIR"
raw_file="$TS_TMP_DIR/$test_case.raw"
mon_file="$TS_TMP_DIR/$test_case.mon"

start_time=$SECONDS
ts_list "$test_file" |
while read lineno test_name
do
  test_dir="$TS_TMP_DIR/$test_case/$test_name"

  # run the test by calling back into the test file
  # * use stdout for progress, stderr for debug information
  # * a zero exit status is considered a pass, otherwise fail
  if
    if [ "true" = "$debug" ]
    then (ts_run_test 2>&1)
    else (ts_run_test 2>/dev/null)
    fi
  then status=P
  else status=F
  fi

  printf "%% %s [%s:%s] %s\n" "$status" "$test_file" "$lineno" "$test_name"
done | ts_process "$raw_file" "$mon_file"
end_time=$SECONDS

ts_report "$raw_file"
}
