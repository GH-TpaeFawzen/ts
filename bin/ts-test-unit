############################################################################
# This file is meant to be sourced into the actual test file.
############################################################################

usr_dir="${TS_USR_DIR:-$(pwd)}"
tmp_dir="${TS_TMP_DIR:-$usr_dir/tmp}"
test_file="$0"
test_case="${test_file##*/}"
test_case="${test_case%\.*}"

############################################################################

setup () {
  true
}

teardown () {
  true
}

# Runs a command and asserts it's exit status is 0.
assert () {
  "$@"
  exitstatus=$?

  if ! [ 0 -eq $exitstatus ]
  then
    printf "exit status %s:\n%s\n" "$exitstatus" "$@"
    exit 1
  fi
}

# Flunks unless the numbers $1 (expected) and $2 (actual) are the same.
assert_status () {
  expected=$1; actual=$2

  if ! [ $actual -eq $expected ]
  then 
    printf "expected status %s but was %s\n" "$expected" "$actual"
    exit 1
  fi
}

# Flunks unless the variables $1 (expected) and $2 (actual) are the same. 
# Reads from stdin for '-'.
assert_output () {
  expected="$1"; actual="$2"

  # use x to protect against '-' on ancient systems
  if [ x"$expected" = x"-" ]
  then expected="$(cat)"
  fi

  if [ x"$actual" = x"-" ]
  then actual="$(cat)"
  fi

  if [ x"$actual" != x"$expected" ]
  then
    mkdir -p "$(dirname "$test_dir")"
    printf "%s" "$expected" > "$test_dir.e.txt"
    printf "%s" "$actual"   > "$test_dir.a.txt"
    printf "unequal output:\n"
    diff "$test_dir.e.txt" "$test_dir.a.txt"
    exit 1
  fi
}

# Flunks unless the extended regular expression $1 (expected pattern) and $2
# (actual) match.  Reads from stdin for '-'.
assert_match () {
  patttern="$1"; actual="$2"

  # use x to protect against '-' on ancient systems
  if [ x"$patttern" = x"-" ]
  then patttern="$(cat)"
  fi

  if [ x"$actual" = x"-" ]
  then actual="$(cat)"
  fi

  if ! [[ "$actual" =~ $patttern ]]
  then
    printf "output does not match pattern: %s\n%s\n" "$patttern" "$actual"
    exit 1
  fi
}

# Runs a specific test.  In that case the test output is not filtered or
# changed. the exit status is the exit status of the specific test.
run_test () {
  if [ -e "$test_dir" ] && ! rm -r "$test_dir"
  then
    printf "could not remove existing test dir: %s\n" "$test_dir"
    exit 1
  fi

  setup
  "$test_name"
  teardown
}

run_tests () {
  grep -onE "^ *test_\w+ +\(\)" "$test_file" |
  tr -d " ()" |
  tr ":" " " |
  while read lineno test_name
  do
    test_dir="$tmp_dir/$test_case/$test_name"

    # run the test by calling back into the test file
    # * use stdout for progress, stderr for debug information
    # * a zero exit status is considered a pass, otherwise fail

    if (run_test "$test_name" <&- 2>/dev/null)
    then status=P
    else status=F
    fi

    printf "%% %s [%s:%s] %s\n" "$status" "$test_file" "$lineno" "$test_name"
  done
}